# üé® CryptoSliceImage: Secure Image Sharing via Threshold Cryptography üñºÔ∏è

This repository presents a detailed exploration and implementation of various threshold secret sharing schemes for securely distributing and reconstructing images. The project focuses on Shamir's Secret Sharing (SSS), Chinese Remainder Theorem (CRT) based secret sharing, and Visual Cryptography (VC), along with enhancements like parallel processing and share encryption.

## üìú Table of Contents

1.  [Project Aim & Overview](#1-project-aim--overview-)
2.  [Core Concepts](#2-core-concepts-%EF%B8%8F)
    * [Threshold Cryptography](#threshold-cryptography-)
    * [Secret Sharing](#secret-sharing-)
3.  [Implemented Schemes & Methodologies](#3-implemented-schemes--methodologies-%EF%B8%8F)
    * [Shamir's Secret Sharing (SSS)](#shamirs-secret-sharing-sss--)
    * [Chinese Remainder Theorem (CRT) Based Secret Sharing](#chinese-remainder-theorem-crt-based-secret-sharing--)
    * [Visual Cryptography (VC)](#visual-cryptography-vc--)
4.  [Key Features & Enhancements Implemented](#4-key-features--enhancements-implemented-%EF%B8%8F)
    * [N+1 Share Method (Integrity Check)](#n1-share-method-integrity-check--)
    * [Parallel Processing for Efficiency](#parallel-processing-for-efficiency-%EF%B8%8F)
    * [Encryption of Shares (AES)](#encryption-of-shares-aes--)
    * [Integrity Verification (Hashing)](#integrity-verification-hashing--)
    * [Randomness Analysis (Entropy)](#randomness-analysis-entropy--)
5.  [Conceptual Network Analysis for Share Distribution](#5-conceptual-network-analysis-for-share-distribution-%EF%B8%8F)
6.  [How It Works (High-Level Steps)](#6-how-it-works-high-level-steps--)
    * [Shamir's Secret Sharing Workflow](#shamirs-secret-sharing-workflow-)
    * [CRT-Based Secret Sharing Workflow](#crt-based-secret-sharing-workflow-)
    * [Visual Cryptography Workflow](#visual-cryptography-workflow-)
7.  [Comparative Analysis: SSS vs. CRT vs. VC](#7-comparative-analysis-sss-vs-crt-vs-vc-%EF%B8%8F)
8.  [Technologies Used](#8-technologies-used-)
9.  [Setup and Usage](#9-setup-and-usage-%EF%B8%8F)
    * [Prerequisites](#prerequisites-)
    * [Running the Implementations](#running-the-implementations-)
10. [Evaluation & Results](#10-evaluation--results-%EF%B8%8F)
11. [Challenges & Future Work](#11-challenges--future-work-%EF%B8%8F)
12. [Team Members](#12-team-members-%EF%B8%8F)

## 1. Project Aim & Overview üéØ

The primary aim of this project is to design, implement, and evaluate robust and efficient systems for secure image sharing based on a threshold mechanism. The system divides a secret image into multiple 'shares' such that the original image can only be reconstructed when a predetermined minimum number (threshold, `k`) of shares are combined. Possessing fewer than `k` shares should reveal no discernible information about the original image content. The project prioritizes security against unauthorized access and explores computational efficiency, particularly for potentially large images, by comparing Shamir's Secret Sharing (SSS), Chinese Remainder Theorem (CRT) based methods, and Visual Cryptography (VC).

## 2. Core Concepts üí°

### Threshold Cryptography
A cryptographic approach where a secret is divided among `n` parties such that any `k` (threshold) of these parties can combine their shares to reconstruct the secret, but any `k-1` or fewer parties cannot gain any information about the secret.

### Secret Sharing
Refers to methods for distributing a secret amongst a group of participants, each of whom is allocated a share of the secret. The secret can be reconstructed only when a sufficient number of shares are combined.

## 3. Implemented Schemes & Methodologies üõ†Ô∏è

### Shamir's Secret Sharing (SSS)  Polynomials
* **Approach:** Leverages polynomial interpolation. For each pixel of a (typically grayscale) image, its intensity value is treated as a secret (the constant term, y-intercept). A random polynomial of degree `k-1` is constructed using this secret.
* **Share Generation:** `n` points (shares) are generated by evaluating this polynomial at `n` distinct non-zero x-coordinates.
* **Reconstruction:** Given at least `k` shares (points), the original polynomial can be reconstructed using Lagrange interpolation, thereby revealing the secret (pixel value).
* **Modulus:** A prime modulus `P` (e.g., `P=257` for 8-bit grayscale images, 0-255 pixel values) is used for all calculations to ensure lossless representation and keep results within a manageable range.

### Chinese Remainder Theorem (CRT) Based Secret Sharing ‚ûï‚ûñ‚úñÔ∏è‚ûó
* **Approach:** Utilizes number theory, specifically the Chinese Remainder Theorem. A secret pixel value `S` is transformed into a system of congruences.
* **Share Generation:** Each share consists of a remainder `S mod m_i`, where `m_i` are pairwise coprime moduli selected for each share. The sequence of moduli `m_1, m_2, ..., m_n` must satisfy specific conditions for secure reconstruction, such as the Asmuth-Bloom condition.
    * **Asmuth-Bloom Condition:** Requires that the product of any `k` moduli is greater than `P` times the product of any `k-1` moduli (where `P` is a large prime greater than the secret). This ensures that `k-1` shares reveal no information.
* **Reconstruction:** Given `k` shares, the original secret (pixel value) can be uniquely determined by solving the system of congruences using the CRT.
* **Parameter Selection:** Careful selection of the moduli sequence and adherence to conditions like Asmuth-Bloom is critical for security and correctness.

### Visual Cryptography (VC) üëÅÔ∏è
* **Approach:** A cryptographic technique that allows visual information (pictures, text, etc.) to be encrypted in such a way that decryption can be performed by the human visual system, typically by stacking shares (transparencies).
* **Basic (2,2) Scheme:** A secret pixel is encoded into two shares. Each share pixel is expanded into a block of subpixels (e.g., 2x2). When shares are overlaid, the black/white pattern of the resulting block reveals the original pixel.
    * Example: For a black pixel, one share might have `BW` and the other `BW` (vertically), resulting in `BB` (black) when stacked. For white, one might be `BW` and other `WB`, resulting in `BW` (gray/half-black, perceived as white relative to full black).
* **(k,n) Scheme:** Generalizes the (2,2) scheme. `k` out of `n` shares are needed to reveal the secret. The implementation detail for general (k,n) VC in this project might be more conceptual or focus on specific constructions.
* **Characteristics:** Lossy (reconstructed image might not be perfect), no complex computation for decryption (just visual alignment).

## 4. Key Features & Enhancements Implemented ‚ú®

Across SSS and CRT schemes, the following features were explored:

### N+1 Share Method (Integrity Check) ‚úÖ
* An additional (`n+1`th) share is generated along with the standard `n` shares.
* During reconstruction, if all `k` shares (out of the first `n`) reconstruct the image correctly, this `n+1`th share can be used to verify the integrity or correctness of the reconstruction by comparing it against a value derived from the reconstructed image and the same share generation parameters. This can help detect if some shares were tampered with, although more robust tamper detection often involves cryptographic hashes or error-correcting codes within the shares.
* The PDF also suggests comparing the reconstructed image from `k` shares with one from `k` other shares, where the (`n+1`)th share acts as a known point.

### Parallel Processing for Efficiency üöÄ
* The `multiprocessing` library in Python was used to parallelize the computationally intensive pixel-wise share generation and reconstruction processes for SSS and CRT.
* This significantly reduces the overall time taken, especially for larger images, by distributing the workload across multiple CPU cores.

### Encryption of Shares (AES) üîí
* To enhance the security of individual shares when stored or transmitted, AES (Advanced Encryption Standard) encryption was applied.
* **Method:** Each generated share (which is numerical data) is converted to bytes, encrypted using AES in CBC (Cipher Block Chaining) mode with a randomly generated Initialization Vector (IV).
* **Key Management:** A user-provided password is used to derive a secure encryption key via PBKDF2 (Password-Based Key Derivation Function 2) with a salt, adding resistance against brute-force attacks on the password.
* Encrypted shares (ciphertext, salt, IV) are stored, and decryption is required before reconstruction.

### Integrity Verification (Hashing) üîó
* SHA256 (Secure Hash Algorithm 256-bit) hashing was used to verify the integrity of the reconstructed image against the original.
* The hash of the original image is computed before creating shares. After reconstruction, the hash of the recovered image is computed and compared with the original hash. A match indicates a successful and untampered reconstruction.

### Randomness Analysis (Entropy) üé≤
* The Shannon entropy of the generated shares (for SSS and CRT) was calculated.
* Higher entropy values suggest greater randomness in the share data, which is a desirable property for security, as it makes it harder to deduce any information about the original secret from individual shares. The goal is for shares to appear as random noise.

## 5. Conceptual Network Analysis for Share Distribution üåê

* The project includes a conceptual integration of the **Max Flow Min Cut algorithm** (using the `networkx` library) to analyze the capacity of a hypothetical network for distributing image shares.
* **Idea:** Model share senders, receivers, and intermediate nodes as a graph with edge capacities. The max flow between a source (distributor) and a sink (reconstructor needing `k` shares) can represent the maximum rate or volume of share data that can be reliably transmitted.
* This part appears to be more of a theoretical analysis or proof-of-concept within the project rather than a fully integrated practical system for network-aware share distribution.

## 6. How It Works (High-Level Steps) üîÑ

### Shamir's Secret Sharing Workflow
1.  **Input:** Grayscale image, threshold `k`, number of shares `n`.
2.  **Share Generation (Pixel-wise & Parallelized):**
    * For each pixel:
        * The pixel value `s_i` is the secret.
        * A random polynomial `P_i(x)` of degree `k-1` is created such that `P_i(0) = s_i`.
        * `n` shares are generated by evaluating `P_i(j)` for `j = 1, ..., n` (all modulo prime `P=257`).
    * (Optional) Shares are encrypted using AES.
3.  **Reconstruction (Pixel-wise & Parallelized):**
    * Input: At least `k` shares.
    * (Optional) Decrypt shares if they were encrypted.
    * For each corresponding set of `k` pixel shares:
        * Use Lagrange Interpolation to reconstruct the polynomial `P_i(x)`.
        * The original pixel value `s_i` is `P_i(0)`.
4.  **Output:** Reconstructed grayscale image. Verify with hash.

### CRT-Based Secret Sharing Workflow
1.  **Input:** Grayscale image, threshold `k`, number of shares `n`.
2.  **Parameter Setup:** Generate a sequence of `n` pairwise coprime moduli `m_1, ..., m_n` satisfying Asmuth-Bloom conditions.
3.  **Share Generation (Pixel-wise & Parallelized):**
    * For each pixel value `s_i`:
        * Generate `n` shares, where the `j`-th share is `s_i mod m_j`.
    * (Optional) Encrypt shares.
4.  **Reconstruction (Pixel-wise & Parallelized):**
    * Input: At least `k` shares and their corresponding moduli.
    * (Optional) Decrypt shares.
    * For each corresponding set of `k` pixel shares:
        * Solve the system of congruences using the Chinese Remainder Theorem to recover `s_i`.
5.  **Output:** Reconstructed grayscale image. Verify with hash.

### Visual Cryptography Workflow
1.  **Input:** Binary (black & white) image, scheme parameters (e.g., (2,2) or conceptual (k,n)).
2.  **Share Generation:**
    * For each pixel of the input image, generate `n` share pixels (or blocks of subpixels).
    * The structure of these share pixels depends on the VC scheme and the original pixel's color, ensuring that combining `k` shares visually reveals the secret.
3.  **Reconstruction:**
    * Physically or digitally overlay (stack) at least `k` of the generated share images.
    * The secret image becomes visible to the human eye due to the combined patterns.

## 7. Comparative Analysis: SSS vs. CRT vs. VC ‚öñÔ∏è

* **SSS:**
    * **Pros:** Simpler setup and mathematical foundation compared to CRT's parameter constraints. Well-understood security.
    * **Cons:** Can be computationally intensive for very large images if not parallelized. Share size is similar to the original pixel data size.
* **CRT-Based:**
    * **Pros:** Can potentially offer performance advantages in some scenarios (e.g., higher `k/n` ratios, specific hardware). Share sizes can be smaller than the original secret if moduli are chosen carefully (though typically similar for pixel values).
    * **Cons:** Requires careful and complex parameter validation (Asmuth-Bloom condition for moduli sequence) which can be non-trivial to implement correctly and efficiently. Incorrect parameters can compromise security or prevent reconstruction.
* **Visual Cryptography (VC):**
    * **Pros:** Extremely simple decryption (visual stacking). No computational power needed for reconstruction.
    * **Cons:** Typically results in loss of image quality/resolution (due to pixel expansion). Limited to primarily binary images for simple schemes. Share size is often larger than the original image (due to pixel expansion). Security can be less robust against sophisticated analysis than computational schemes.

The project concludes that SSS is often simpler to implement correctly, while CRT offers an alternative with its own set of complexities and potential benefits. VC serves a different niche where computational-free decryption is paramount.

## 8. Technologies Used üíª

* **Programming Language:** Python üêç
* **Image Processing:** Pillow (PIL) üñºÔ∏è
* **Numerical Operations:** NumPy (potentially for array manipulations)
* **Cryptography:**
    * PyCryptodome (`Crypto.Cipher.AES`, `Crypto.Protocol.KDF.PBKDF2`, `Crypto.Random`) for share encryption.
    * `hashlib` (SHA256) for integrity checks.
    * `secrets` for cryptographically strong random number generation (used in SSS).
* **Parallel Processing:** `multiprocessing` module.
* **Mathematical Utilities:** `math` module.
* **Data Visualization:** `matplotlib.pyplot` (for displaying images or entropy plots).
* **Network Analysis (Conceptual):** `networkx` (for Max Flow graph algorithm).

## 9. Setup and Usage ‚öôÔ∏è

### Prerequisites
* Python 3.x installed.
* Install necessary libraries:
    ```bash
    pip install Pillow numpy pycryptodomex matplotlib networkx
    ```

### Running the Implementations
* The project likely consists of several Python scripts, each demonstrating a specific scheme (SSS, CRT, VC) or feature (parallelism, encryption).
* **General Steps:**
    1.  Prepare an input image (typically grayscale for SSS/CRT, binary for basic VC).
    2.  Modify the script(s) to point to your input image file.
    3.  Set parameters like `k` (threshold) and `n` (number of shares).
    4.  Run the script for share generation. Shares might be saved as images or data files.
    5.  Run the corresponding script for image reconstruction, providing the required `k` shares.
    6.  Observe the reconstructed image and any integrity/entropy reports.
* Refer to the specific comments and structure within each Python file provided in the project for detailed usage instructions.

## 10. Evaluation & Results üéâ

* **Integrity:** Successful reconstruction of images was verified by comparing the SHA256 hash of the reconstructed image with the original.
* **Share Randomness:** Entropy calculations for SSS and CRT shares confirmed that the shares possess high entropy, appearing random and thus not leaking information about the secret image individually.
* **Visual Cryptography:** Visual inspection of stacked shares demonstrated the successful hiding and revealing of the secret image as per the VC scheme used.
* **Performance:** The use of `multiprocessing` showed a significant improvement in the time taken for share generation and reconstruction for SSS and CRT, especially with larger images.
* **Encryption:** AES encryption successfully secured individual shares, requiring the correct password for decryption before reconstruction.

## 11. Challenges & Future Work üîÆ

* **Robust Parameter Selection for CRT:** Automating and ensuring the correctness of Asmuth-Bloom parameter generation for CRT is a complex area that could be improved for better usability and security assurance.
* **Advanced Visual Cryptography Schemes:** Exploring and implementing more sophisticated (k,n) VC schemes for grayscale or color images, or schemes with better resolution/contrast.
* **Practical Network Analysis Implementation:** Moving beyond the conceptual Max Flow model to a more practical system that considers real-world network latencies, bandwidths, and node reliability for optimized and secure share distribution.
* **Error Correction:** Integrating error-correcting codes (ECC) with secret sharing (especially SSS or CRT) to handle not just missing shares but also corrupted or tampered shares up to a certain limit.
* **Hybrid Approaches:** Combining different techniques, for example, using VC for a quick, low-fidelity preview and SSS/CRT for the secure reconstruction of high-fidelity numerical data.

## 12. Team Members üßë‚Äçüíª

* S.Azhagesh (23BCE1205)
* Giridharen Goguladhevan (23BCE5043)
* Rohith Ganesh Kanchi (23BCE5049)
* S.D. Madhumitha (23BCE5058)

*(Based on the provided PDF for "Secure Image Sharing Using Threshold Cryptography...")*

---

This README provides a detailed breakdown of the project as understood from the "Report_problem2.pdf".
